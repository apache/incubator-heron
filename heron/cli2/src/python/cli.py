#!/usr/bin/python2.7

import argparse
import atexit
import base64
import contextlib
import errno
import glob
import logging
import logging.handlers
import os
import re
import shutil
import sys
import subprocess
import tarfile
import tempfile

from heron.proto import topology_pb2

CONFIG_OPTS = {}

VERBOSE = False

TOPOLOGY_RUN_JARS = ['lib/protobuf-java-2.5.0.jar',
                     'lib/log4j-over-slf4j-1.7.7.jar',
                     'lib/slf4j-api-1.7.7.jar',
                     'lib/slf4j-jdk14-1.7.7.jar']
SCHEDULER_RUN_JARS = ['lib/heron-scheduler.jar']

# Create the logger
Log = logging.getLogger('heron_cli2')

def configure(level, logfile = None):
  log_format = "%(asctime)s-%(levelname)s: %(message)s"
  date_format = '%a, %d %b %Y %H:%M:%S'

  logging.basicConfig(format=log_format, datefmt=date_format)
  Log.setLevel(level)

  if (logfile != None):
    fh = logging.FileHandler(logfile)
    fh.setFormatter(logging.Formatter(log_format))
    Log.addHandler(fh)

def create_tar(tar_filename, files):
  with contextlib.closing(tarfile.open(tar_filename, 'w:gz')) as tar:
    for filename in files:
      if not os.path.isfile(filename):
        raise Exception("%s is not an existing file" % filename)
      tar.add(filename, arcname=os.path.basename(filename))

def identity(x):
    return x

def cygpath(x):
    command = ['cygpath', '-wp', x]
    p = subprocess.Popen(command,stdout=subprocess.PIPE)
    output, errors = p.communicate()
    lines = output.split("\n")
    return lines[0]

if sys.platform == 'cygwin':
    normclasspath = cygpath
else:
    normclasspath = identity

def get_config_opts():
  opt_list = []
  for (k, v) in CONFIG_OPTS.items():
    opt_list.append('%s=%s' % (k, v))
  return '-Dheron.options=' + (','.join(opt_list)).replace(' ', '%%%%')

def get_heron_dir():
  """
  This will extract heron directory from .pex file.
  :return: root location for heron-cli.
  """
  return normclasspath("/".join(os.path.realpath( __file__ ).split('/')[:-7]))

def pass_cmdline_override(namespace):
  override = []
  for key in namespace.keys():
    # Notice we could not use "if not namespace[key]",
    # since it would filter out 0 too, rather than just "None"
    if namespace[key] is None:
      continue
    property_key = key.replace('-', '.').replace('_', '.')
    property_value = str(namespace[key])
    override.append('%s="%s"' % (property_key, property_value))
  return ' '.join(override)

def get_heron_libs(localjars):
  heron_dir = get_heron_dir()
  return [ os.path.join(heron_dir, f) for f in localjars ]

def get_classpath(jars):
  return ':'.join(map(normclasspath, jars))

def exec_heron_class(klass, libjars, extrajars=[], args=[]):
  all_args = [
      "java", "-client", "-Xmx1g", get_config_opts(),
      "-cp", get_classpath(libjars + extrajars),
  ] + [klass] + list(args)

  if VERBOSE:
    print('$> %s' % ' '.join(all_args))
  status = subprocess.call(all_args)
  if status != 0:
    print "User main failed with status %d. Bailing out..." % status
    sys.exit(1)

def verify_options():
  # TODO: Verify command-line
  pass

def exec_heron_tar(klass,
                   topology_tar,
                   args,
                   tmpdir_root):
  # Extract tar to a tmp folder.
  tmpdir = tempfile.mkdtemp(dir=tmpdir_root, prefix='tmp')
  with contextlib.closing(tarfile.open(topology_tar)) as tar:
    tar.extractall(path=tmpdir)
  # A tar generated by pants has all dependency jars under libs/
  # in addition to the topology jar at top level.
  # And pants keeps filename for jar and tar the same except for
  # extension.
  # TODO: We need to extract heron-core to separate folder.
  topology_jar = os.path.basename(topology_tar).replace(".tar.gz", "").replace(".tar", "") + ".jar"
  extrajars = [os.path.join(tmpdir, "heron-instance.jar"),
               os.path.join(tmpdir, topology_jar),
               os.path.join(tmpdir, "*"),
               os.path.join(tmpdir, "libs/*")]
  # Find all jars and put them in classpath and execute class
  exec_heron_class(klass, get_heron_libs(TOPOLOGY_RUN_JARS), extrajars, args)

def launch_one_topology(tmpdir,
                        jar_or_tar,
                        defn_file,
                        heron_internals_config_filename,
                        submitter_config_loader,
                        submitter_config,
                        scheduler_overrides):
  pkg_path = normclasspath(os.path.join(tmpdir, 'topology.tar.gz'))
  heron_internals_config_path = os.path.join(get_heron_dir(), heron_internals_config_filename)
  create_tar(pkg_path, [jar_or_tar, defn_file, heron_internals_config_path])

  # Launch topology
  exec_heron_class('com.twitter.heron.scheduler.service.SubmitterMain',
                   get_heron_libs(SCHEDULER_RUN_JARS),
                   extrajars=[],
                   args=[ pkg_path,
                          submitter_config_loader,
                          submitter_config,
                          base64.b64encode(scheduler_overrides),
                          defn_file,
                          heron_internals_config_path,
                          jar_or_tar]);

def launch_all_topologies_found(jar_or_tar_file, tmpdir, submitter_config_loader, submitter_config, scheduler_overrides):
  # The HeronSubmitter would have written the .defn file to the tmpdir
  defn_files = glob.glob(tmpdir + '/*.defn')

  # TODO: We may add the flexibility to overload this file later
  heron_internals_config_filename = 'heron_internals.yaml'
  if len(defn_files) == 0:
    raise Exception("No topologies found")

  try:
    for defn_file in defn_files:
      topology_defn = topology_pb2.Topology()
      try:
        f = open(defn_file, "rb")
        topology_defn.ParseFromString(f.read())
        f.close()
      except:
        raise Exception("Could not open and parse topology defn file %s" % defn_file)

      try:
        print "Launching topology %s" % topology_defn.name
        launch_one_topology(tmpdir,
                            jar_or_tar_file,
                            defn_file,
                            heron_internals_config_filename,
                            submitter_config_loader,
                            submitter_config,
                            scheduler_overrides)
        print "Topology %s Launched Successfully" % topology_defn.name
      except Exception as ex:
        print 'Failed to launch topology %s because %s' % (topology_defn.name, str(ex))
        raise
  except:
    raise

def submitfatjar(namespace):
  """Syntax: heron-cli submitfatjar <dc>/<role>/<environ> topology-jar-path class args

  WARNING: jar format will be depricated soon. Use tar
  compressed format instead.

  We use the packer to make a package for the jar and dump it
  to a well-known location. We then run the main method of class
  with the specified arguments. We pass arguments as heron.options.
  This will run the jar file with the klass name. The HeronSubmitter
  inside will write out the topology defn file to a location that
  we specify. Then we write the topology defn file to a well known
  packer location. We then write to appropriate places in zookeeper
  and launch the aurora jobs
  """
  jarfile = namespace['filepath']
  klass = namespace['classname']
  args = tuple(namespace['heron_unknown_args'])

  print 'Deprecation Warning: fatjar will be deprecated soon. Please use tar format ..'
  specified_tmpdir = namespace['tmp_dir']
  if specified_tmpdir is not None:
    tmpdir = specified_tmpdir
    # Making sure the dir exists
    mkdir_p(tmpdir)
    # Cleaning up all the previous defn files in the tmp dir
    purge(tmpdir, '^.+\.defn$')
  else:
    tmpdir = tempfile.mkdtemp()

  set_config_opt('cmdline.topologydefn.tmpdirectory', tmpdir)

  if namespace['deactivated']:
    initial_state = topology_pb2.TopologyState.Name(topology_pb2.PAUSED)
  else:
    initial_state = topology_pb2.TopologyState.Name(topology_pb2.RUNNING)

  set_config_opt('cmdline.topology.initial.state', initial_state)

  exec_heron_class(klass,
                   get_heron_libs(TOPOLOGY_RUN_JARS),
                   extrajars=[jarfile],
                   args=args)

  try:
    scheduler_overrides = namespace['config-overrides'] + ' ' + pass_cmdline_override(namespace)
    launch_all_topologies_found(jarfile,
                                tmpdir,
                                namespace['config_loader'],
                                namespace['config_path'],
                                scheduler_overrides)
  finally:
    if specified_tmpdir is None:
        shutil.rmtree(tmpdir)

def purge(dir, pattern):
    for f in os.listdir(dir):
        if re.search(pattern, f):
            os.remove(os.path.join(dir, f))

def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise

def submittar(namespace):
  """Syntax: heron-cli submittar <dc>/<role>/<environ> topology-tar-path class args

  Extract and execute the java files inside the tar and then add topology
  definition file created by running submitTopology
  We use the packer to make a package for the tar and dump it
  to a well-known location. We then run the main method of class
  with the specified arguments. We pass arguments as heron.options.
  This will run the jar file with the klass name. The HeronSubmitter
  inside will write out the topology defn file to a location that
  we specify. Then we write the topology defn file to a well known
  packer location. We then write to appropriate places in zookeeper
  and launch the aurora jobs
  """
  tar_name = namespace['filepath']
  klass = namespace['classname']
  args = tuple(namespace['heron_unknown_args'])

  tmpdir = tempfile.mkdtemp()
  set_config_opt('cmdline.topologydefn.tmpdirectory', tmpdir)

  if namespace['deactivated']:
    initial_state = topology_pb2.TopologyState.Name(topology_pb2.PAUSED)
  else:
    initial_state = topology_pb2.TopologyState.Name(topology_pb2.RUNNING)

  set_config_opt('cmdline.topology.initial.state', initial_state)

  exec_heron_tar(klass, tar_name, args, tmpdir)
  try:
    scheduler_overrides = namespace['config-overrides'] + ' ' + pass_cmdline_override(namespace)
    launch_all_topologies_found(tar_name,
                                tmpdir,
                                namespace['config_loader'],
                                namespace['config_path'],
                                scheduler_overrides)
  finally:
    shutil.rmtree(tmpdir)

def submit(namespace):
  """Syntax: heron-cli submit <dc>/<role>/<environ> topology-tar-or-jar-path class args

  Submits the topology to be run in Aurora.
  1) Depending on whether the topology filename extention we
     treat the file as a fatjar(if the ext is .jar)
     or a tar file(if the ext is .tar).
  2) We upload the topology file to the packer, update zookeeper
     and launch aurora jobs representing that topology
  3) You can see your topology at http://go/heronui
  """
  filename = namespace['filepath']
  # Check to see if the file exists
  if not os.path.isfile(filename):
    print "Topology jar/tar %s does not exist" % filename
    sys.exit(1)
  # Check the extension of the file name
  # to see if it is tar or jar file.
  if filename.endswith(".jar"):
    submitfatjar(namespace)
  elif filename.endswith(".tar") or filename.endswith(".tar.gz"):
    submittar(namespace)
  else:
    print "Unknown file type. Please use .tar or .jar file"
    sys.exit(1)

def runtime_manage(namespace):
  """Syntax: heron-cli command <dc>/<role>/<environ> topologyname <optionally arguments>

  Commands supported are: kill, activate, deactivate and restart

  1. Kill
  Syntax: heron-cli kill <dc>/<role>/<environ> <topologyname>

  Kills the topology
  1) We kill the jobs representing that topology
  2) We cleanup the state associated with the topology

  2. Activate
  Syntax: heron-cli activate <dc>/<role>/<environ> topologyname

  Activates a topology. Essentially the topology starts emitting tuples again.

  3. Deactivate
  Syntax: heron-cli deactivate <dc>/<role>/<environ> topologyname

  DeActivates a topology. Essentially the topology stops emitting tuples"

  4. Restart
  Syntax: heron-cli restart <dc>/<role>/<environ> topologyname <optionally container id>

  Just restarts the topology. This is faster than a submit because the topology
  jar/tar need not be uploaded.
  """
  topology_name = namespace['topology']
  command = namespace['command']

  try:
    config_overrides = namespace['config-overrides'] + ' ' + pass_cmdline_override(namespace)

    exec_heron_class('com.twitter.heron.scheduler.service.RuntimeManagerMain',
                     get_heron_libs(SCHEDULER_RUN_JARS),
                     extrajars=[],
                     args=[ command,
                            topology_name,
                            namespace['config_loader'],
                            base64.b64encode(config_overrides),
                            namespace['config_path']])

  except Exception as ex:
    print "Failed to %s topology" %command
    sys.exit(1)

  print "Successfully %s topology" %command
  sys.exit(0)

def print_classpath(namespace):
  """Syntax: heron-cli classpath

  Prints the classpath used by the heron client when running commands.
  """
  print get_classpath([])

def print_version(namespace):
  """Syntax: heron-cli version

  Prints heron-cli version.
  """
  with open(os.path.join(get_heron_dir(), 'RELEASE')) as data_file:
    version = data_file.read()
    print "Version: " + str(version)

def set_config_opt(k, v):
  # store CONFIG_OPTS in global variable.
  global CONFIG_OPTS
  CONFIG_OPTS[k] = v

COMMANDS = {
             "submit": submit,
             "classpath": print_classpath,
             "version": print_version,
             "kill": runtime_manage,
             "activate": runtime_manage,
             "deactivate": runtime_manage,
             "restart": runtime_manage
           }

def create_parser():
  # Main parser
  parser = argparse.ArgumentParser(epilog = 'Documentation at http://go/heron')
  subparsers = parser.add_subparsers()

  # submit
  submit_parser = subparsers.add_parser('submit', help='Submit a topology', add_help=False)
  submit_parser.add_argument('config-overrides', help='Override scheduler config to provide dc/role/env')
  submit_parser.add_argument('filepath', help='jar or tar filepath')
  submit_parser.add_argument('classname', help='classname')
  submit_parser.add_argument('--config-path', help='Scheduler config path', default=os.path.join(get_heron_dir(), 'conf/com/twitter/aurora'))
  submit_parser.add_argument('--config-loader', help='Scheduler config loader classname', default='com.twitter.heron.scheduler.aurora.AuroraConfigLoader')
  submit_parser.add_argument('--config-property', help="scheduler config properties", action='append', default=[])
  submit_parser.add_argument('--deactivated', help='Deploy topology in deactivated initial state', action='store_true')
  submit_parser.add_argument('--tmp-dir', help='Tmp dir to store .defn files in')
  submit_parser.add_argument('--verbose', action='store_true')
  submit_parser.set_defaults(command='submit')

  # kill
  kill_parser = subparsers.add_parser('kill', help='Kill a topology')
  kill_parser.add_argument('config-overrides', help='Override killer config to provide dc/role/env')
  kill_parser.add_argument('topology', help='topology name')
  kill_parser.add_argument('--config-path', help='Killer config path', default=os.path.join(get_heron_dir(), 'conf/com/twitter/aurora'))
  kill_parser.add_argument('--config-loader', help='Killer config loader classname', default='com.twitter.heron.scheduler.aurora.AuroraConfigLoader')
  kill_parser.add_argument('--config-property', help="Killer config properties", action='append', default=[])
  kill_parser.add_argument('--verbose', action='store_true')
  kill_parser.set_defaults(command='kill')

  # activate
  activate_parser = subparsers.add_parser('activate', help='Activate a topology')
  activate_parser.add_argument('config-overrides', help='Override activator config to provide dc/role/env')
  activate_parser.add_argument('topology', help='topology name')
  activate_parser.add_argument('--config-path', help='Activator config path', default=os.path.join(get_heron_dir(), 'conf/com/twitter/aurora'))
  activate_parser.add_argument('--config-loader', help='Activator config loader classname', default='com.twitter.heron.scheduler.aurora.AuroraConfigLoader')
  activate_parser.add_argument('--config-property', help="Activator config properties", action='append', default=[])
  activate_parser.add_argument('--verbose', action='store_true')
  activate_parser.set_defaults(command='activate')

  # deactivate
  deactivate_parser = subparsers.add_parser('deactivate', help='Deactivate a topology')
  deactivate_parser.add_argument('config-overrides', help='Override deactivator config to provide dc/role/env')
  deactivate_parser.add_argument('topology', help='topology name')
  deactivate_parser.add_argument('--config-path', help='Deactivator config path', default=os.path.join(get_heron_dir(), 'conf/com/twitter/aurora'))
  deactivate_parser.add_argument('--config-loader', help='Deactivator config loader classname', default='com.twitter.heron.scheduler.aurora.AuroraConfigLoader')
  deactivate_parser.add_argument('--config-property', help="Deactivator config properties", action='append', default=[])
  deactivate_parser.add_argument('--verbose', action='store_true')
  deactivate_parser.set_defaults(command='deactivate')

  # restart
  restart_parser = subparsers.add_parser('restart', help='Restart a topology')
  restart_parser.add_argument('config-overrides', help='Override restarter config to provide dc/role/env')
  restart_parser.add_argument('topology', help='topology name')
  restart_parser.add_argument('shard', nargs='?', type=int, default=-1, help='shard id to be restarted')
  restart_parser.add_argument('--config-path', help='Restarter config path', default=os.path.join(get_heron_dir(), 'conf/com/twitter/aurora'))
  restart_parser.add_argument('--config-loader', help='Restarter config loader classname', default='com.twitter.heron.scheduler.aurora.AuroraConfigLoader')
  restart_parser.add_argument('--config-property', help="Restarter config properties", action='append', default=[])
  restart_parser.add_argument('--verbose', action='store_true')
  restart_parser.set_defaults(command='restart')

  # classpath
  classpath_parser = subparsers.add_parser('classpath', help='Print classpath of heron-cli')
  classpath_parser.add_argument('--verbose', action='store_true')
  classpath_parser.set_defaults(command='classpath')

  # version
  version_parser = subparsers.add_parser('version', help='Print version of heron-cli')
  version_parser.add_argument('--verbose', action='store_true')
  version_parser.set_defaults(command='version')

  return parser

def cleanup():
  pass

def main():
  global VERBOSE
  configure(logging.WARN)
  parser = create_parser()
  args, unknown_args = parser.parse_known_args()
  namespace = vars(args)
  COMMAND = namespace['command']
  VERBOSE = namespace['verbose']
  namespace['heron_verbose'] = namespace['verbose']
  del namespace['verbose']
  if (COMMAND != 'version' and COMMAND != 'classpath'):
    namespace['heron_dir'] = get_heron_dir()
    namespace['heron_config_path'] = namespace['config_path']
    namespace['heron_config_loader'] = namespace['config_loader']
    if os.path.isfile(namespace['config_path']):
      namespace['config_file'] = namespace['config_path']
      namespace['heron_config_file'] = namespace['config_path']
    namespace['heron_unknown_args'] = unknown_args
    if namespace.get('config_property') != None:
      namespace['config_property'] = " ".join(namespace['config_property'])
  atexit.register(cleanup)
  (COMMANDS.get(COMMAND))(namespace)

if __name__ == "__main__":
    main()
