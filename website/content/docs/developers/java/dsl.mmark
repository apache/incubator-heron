---
title: The Heron DSL for Java
description: Create Heron topologies in Java using a functional programming style
---

{{content/snippets/heron-dsl.md}}

## Getting started

In order to use the Heron DSL for Java, you'll need to install the `heron-dsl` library.

### Maven setup

In order to use the `heron-dsl` library, add this to the `dependencies` block of your `pom.xml` configuration file:

```xml
<dependency>
    <groupId>com.twitter.heron</groupId>
    <artifactId>heron-dsl</artifactId>
    <version>{{< heronVersion >}}</version>
</dependency>
```

#### Compiling a JAR with dependencies

In order to run a Java DSL topology in a Heron cluster, you'll need to package your topology as a "fat" JAR with dependencies included. You can use the [Maven Assembly Plugin](https://maven.apache.org/plugins/maven-assembly-plugin/usage.html) to generate JARs with dependencies. To install the plugin and add a Maven goal for a single JAR, add this to the `plugins` block in your `pom.xml`:

```xml
<plugin>
    <artifactId>maven-assembly-plugin</artifactId>
    <configuration>
        <descriptorRefs>
            <descriptorRef>jar-with-dependencies</descriptorRef>
        </descriptorRefs>
        <archive>
            <manifest>
                <mainClass></mainClass>
            </manifest>
        </archive>
    </configuration>
    <executions>
        <execution>
            <id>make-assembly</id>
            <phase>package</phase>
            <goals>
                <goal>single</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

Once your `pom.xml` is properly set up, you can compile the JAR with dependencies using this command:

```bash
$ mvn assembly:assembly
```

By default, this will add a JAR in your project's `target` folder with the name `PROJECT-NAME-VERSION-jar-with-dependencies.jar`. Here's an example topology submission command using a compiled JAR:

```bash
$ mvn assembly:assembly
$ heron submit local \
  target/my-project-1.2.3-jar-with-dependencies.jar \
  com.example.Main \
  MyTopology arg1 arg2
```

#### Java DSL starter project

If you'd like to up and running quickly with the Java DSL, you can clone [this repository](https://github.com/streamlio/heron-java-dsl-example), which includes an example topology built using the DSL as well as the necessary Maven configuration. To build a JAR with dependencies of this example topology:

```bash
$ git clone https://github.com/streamlio/heron-java-dsl-example
$ cd heron-java-dsl-example
$ mvn assembly:assembly
$ ls target/*.jar
heron-java-dsl-example-0.1.0-jar-with-dependencies.jar
heron-java-dsl-example-0.1.0.jar
``` 

## Full example



## Creating processing logic

All Java DSL processing graphs begin with a `Builder` object:

```java
import com.twitter.heron.dsl.Builder;

Builder builder = Builder.CreateBuilder();
```

## Streamlets

In the Heron DSL for Java, processing graphs consist of [streamlets](../../../concepts/topologies#streamlets). One or more supplier streamlets inject data (of whichever type) you'd like

## Operations

Operation | Description | Example
:---------|:------------|:-------
`map` | Create a new streamlet by applying the supplied mapping function to each element in the original streamlet | Add 1 to each element in a streamlet of integers
`flatMap` | Like a map operation but with the important difference that each element of the streamlet is flattened | Flatten a sentence into individual words
`join` | Create a new streamlet by combining two separate key-value streamlets into one on the basis of each element's key | Combine key-value pairs listing current scores (e.g. `("h4x0r", 127)`) for each user into a single per-user stream
`union` | Create a new streamlet by combining two separate non-key-value streamlets into one | Combine two integer streamlets into one
`filter` | Create a new streamlet containing only the elements that satisfy the supplied filtering function | Remove all inappropriate words from a streamlet of strings
`repartition` | Create a new streamlet by applying a new parallelism level to the original streamlet | Increase the parallelism of a streamlet from 5 to 10
`mapToKV` | Create a new key-value streamlet by converting each element in the original streamlet into a `KeyValue` object | Convert each element of a string streamlet into a `KeyValue` object where the current time is the key and the original string is the value
`log` | | Output the final results of a processing graph to stdout

### Map operations

Map operations create a new streamlet by applying the supplied mapping function to each element in the original streamlet. Here's an example:

```java
Builder.newSource(() -> 1)
    .map(i -> i + 1);
```

In this example,

### FlatMap operations

FlatMap operations are like map operations but with the important difference that each element of the streamlet is "flattened" into another type. In this example, a supplier streamlet emits the same sentence over and over again; the `flatMap` operation transforms each sentence into a Java `List` of individual words:

```java
Builder.newSource(() -> "I have nothing to declare but my genius")
    .flatMap((sentence) -> Arrays.asList(sentence.split("\\s+")));
```

The effect of this operation is to transform each `Streamlet<String>` into a `Streamlet<List<String>>`.

> One of the core differences between map and flatMap operations is that flatMap operations typically transform non-collection types into collection types.

### Join operations

```java
Builder builder = Builder.CreateBuilder();

Streamlet<KeyValue<String, String>> streamlet1 =
        builder.newSource(() -> new KeyValue<>("heron-api", "topology"));

Builder.newSource(() -> new KeyValue<>("heron-api", "dsl"))
    .join(streamlet1);
```

### Left join operations

### Outer join operations

### Filter operations



## Parallelism

In the original, Storm-inspired topology API for Heron, you could control parallelism within your topologies by controlling the number of spouts or bolts performing a specific ingestion or processing operation. The Heron DSL is different in that 