---
title: The Heron ECO API for Java
description: Create Heron topologies in Java from reusable spouts and bolts
---

{{< alert "eco-api-beta" >}}

{{content/snippets/heron-eco-api.md}}


## What about Storm Flux?  Is it compatible with Eco?

ECO is an evolution of Flux.  Most Storm Flux topologies should be able to deployed in Heron with minimal changes.
Start reading [Migrate Storm Topologies To Heron] (../../../migrate-storm-to-heron) to learn how to migrate your Storm Flux topology then come back.

## Getting started

In order to use the Heron ECO for Java, you'll need to install the `heron-api` and the `heron-storm` library, which is available
via [Maven Central](http://search.maven.org/).

### Maven setup

To install the `heron-api` library using Maven, add this to the `dependencies` block of your `pom.xml`
configuration file:

```xml
<dependency>
    <groupId>com.twitter.heron</groupId>
    <artifactId>heron-api</artifactId>
    <version>{{< heronVersion >}}</version>
    <scope>compile</scope>
</dependency>
<dependency>
    <groupId>com.twitter.heron</groupId>
    <artifactId>heron-storm</artifactId>
    <version>{{< heronVersion >}}</version>
    <scope>compile</scope>
</dependency>
```

#### Compiling a JAR with dependencies

In order to run a Java topology in a Heron cluster, you'll need to package your topology as a "fat" JAR with dependencies included. You can use the [Maven Assembly Plugin](https://maven.apache.org/plugins/maven-assembly-plugin/usage.html) to generate JARs with dependencies. To install the plugin and add a Maven goal for a single JAR, add this to the `plugins` block in your `pom.xml`:

```xml
<plugin>
    <artifactId>maven-assembly-plugin</artifactId>
    <configuration>
        <descriptorRefs>
            <descriptorRef>jar-with-dependencies</descriptorRef>
        </descriptorRefs>
        <archive>
            <manifest>
                <mainClass></mainClass>
            </manifest>
        </archive>
    </configuration>
    <executions>
        <execution>
            <id>make-assembly</id>
            <phase>package</phase>
            <goals>
                <goal>single</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

Once your `pom.xml` is properly set up, you can compile the JAR with dependencies using this command:

```bash
$ mvn assembly:assembly
```

By default, this will add a JAR in your project's `target` folder with the name `PROJECT-NAME-VERSION-jar-with-dependencies.jar`. Here's an example ECO topology submission command using a compiled JAR:

```bash
$ heron submit local \
  target/my-project-1.2.3-jar-with-dependencies.jar \
  com.twitter.heron.eco.Eco \
  --eco-config-file path/to/your/topology-definition.yaml
```

Notice how the above example submission command is referencing the main class `com.twitter.heron.eco.Eco`.  This part of the command
needs to stay the same.  Eco is the main class that will assemble your topology from the `--eco-config-file` you specify.

## Defining Your ECO Topology File

An ECO topology definition consists of the following:

* A topology name
* An optional list of topology "components" (named Java objects that will be made available in the environment)
* A DSL topology definition that contains:
  - A list of spouts, each identified by a unique ID
  - A list of bolts, each identified by a unique ID
  - A list of "stream" objects representing a flow of tuples between spouts and bolts


An example of a simple YAML DSL definition is below:

```yaml

name: "fibonacci-topology"

config:
  topology.workers: 1

components:
  - id: "property-holder"
    className: "com.twitter.heron.examples.eco.TestPropertyHolder"
    constructorArgs:
      - "some argument"

spouts:
  - id: "spout-1"
    className: "com.twitter.heron.examples.eco.TestFibonacciSpout"
    constructorArgs:
      - ref: "property-holder"
    parallelism: 1

bolts:
  - id: "even-and-odd-bolt"
    className: "com.twitter.heron.examples.eco.EvenAndOddBolt"
    parallelism: 1

  - id: "ibasic-print-bolt"
    className: "com.twitter.heron.examples.eco.TestIBasicPrintBolt"
    parallelism: 1

  - id: "sys-out-bolt"
    className: "com.twitter.heron.examples.eco.TestPrintBolt"
    parallelism: 1

streams:
  - name: "spout-1 --> even-and-odd-bolt" # name isn't used (placeholder for logging, UI, etc.)
    from: "spout-1"
    to: "even-and-odd-bolt"
    grouping:
      type: SHUFFLE

  - name: "even-and-odd-bolt --> ibasic-print-bolt"
    from: "even-and-odd-bolt"
    to: "ibasic-print-bolt"
    grouping:
      type: SHUFFLE
      streamId: "odds"

  - name: "even-and-odd-bolt --> sys-out-bolt"
    from: "even-and-odd-bolt"
    to: "sys-out-bolt"
    grouping:
      type: SHUFFLE
      streamId: "evens"

```

If you want to stop here and try to deploy the above topology you can execute

```bash
$ heron submit local \
  ~/.heron/examples/heron-eco-examples.jar \
  com.twitter.heron.eco.Eco \
  --eco-config-file ~/.heron/examples/fibonacci.yaml
```

This ECO topology doesn't do anything spectacular, but it's a good starting point to go through some ECO's concepts.

##Taking a closer look at the YAML definition specs

### Topology Name

Each ECO definition file will be required to have a `name` defined.

```yaml

name: "simple-wordcount-topology"

```

### Configuration

`config` the section where you will list your properties to be inserted into a `org.apache.storm.Config` class.
It will accept any key value pair, but this is where you specify your Storm topology configs. This section is optional.

```yaml

config:
  topology.workers: 1

```

### Components

`components` are a list of instances that would be used as configuration objects for other components in your ECO file defined in the YAML DSL
The properties that are required for each `component` instance are `id` and `className`.  The `id` the field used to identify
the component for injection in the coming spouts and bolts defined in the topology.  `constructorArgs` is only needed
if a component has constructor that requires arguments.  We will get into constructor args the in the next section.  `components` are optional

```yaml

components:
  - id: "property-holder"
    className: "com.twitter.heron.examples.eco.TestPropertyHolder"
    constructorArgs:
      - "some argument"

```

`constructorArgs` can specify any object type.  Above you can see that the only constructor argument specified is a string
that contained "some argument".  The is also a way to reference other components as arguments by using `ref`.  In the example
below we are specifying an already defined component to be a constructor argument.  Any instance that is referenced by
`ref` must have already been defined in the ECO definition file before it is to be used.

```yaml

constructorArgs:
      - ref: "property-holder"

```


